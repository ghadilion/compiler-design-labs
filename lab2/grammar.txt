translation_unit : {external_declaration}*

external_declaration : function_definition
                         | declaration

function_definition : type_specifier declarator {declaration}* compound_statement

type_specifier : VOID
                   | CHAR
                   | INT
                   | FLOAT
                   | STRING
                   | DATATYPE
                   | BOOL

declarator : {pointer}? direct_declarator

pointer : DOT {pointer}?

direct_declarator : identifier
                      | ( declarator )
                      | direct_declarator [ {constant_expression}? ]
                      | direct_declarator ( parameter_list )
                      | direct_declarator ( {identifier}* )

constant_expression : logical_or_expression

logical_or_expression : logical_and_expression
                          | logical_or_expression OR logical_and_expression

logical_and_expression : equality_expression
                           | logical_and_expression AND equality_expression

equality_expression : relational_expression
                        | equality_expression EQUALS relational_expression
                        | equality_expression NEQUALS relational_expression

relational_expression : additive_expression
                          | relational_expression LT additive_expression
                          | relational_expression GT additive_expression
                          | relational_expression LTE additive_expression
                          | relational_expression GTE additive_expression

additive_expression : multiplicative_expression
                        | additive_expression PLUS multiplicative_expression
                        | additive_expression MINUS multiplicative_expression

multiplicative_expression : cast_expression
                              | multiplicative_expression MUL cast_expression
                              | multiplicative_expression DIV cast_expression
                              | multiplicative_expression MOD cast_expression

cast_expression : unary_expression
                    | ( type_name ) cast_expression

unary_expression : postfix_expression
                     | DECR unary_expression
                     | INCR unary_expression
                     | unary_operator cast_expression

postfix_expression : primary_expression
                       | postfix_expression [ expression ]
                       | postfix_expression ( {assignment_expression}* )
                       | postfix_expression COLON identifier
                       | postfix_expression INCR
                       | postfix_expression DECR

primary_expression : identifier
                       | constant
                       | string
                       | ( expression )

constant : integer_constant
             | character_constant
             | floating_constant

expression : assignment_expression
               | expression , assignment_expression

assignment_expression : unary_expression assignment_operator assignment_expression

assignment_operator : ASSIGN
                        | MULEQUALS
                        | DIVEQUALS
                        | MODEQUALS
                        | PLUSEQUALS
                        | MINUSEQUALS

unary_operator : MUL
                   | PLUS
                   | MINUS
                   | ~ 
                   | NOT

parameter_list : parameter_declaration
                   | parameter_list COMMA parameter_declaration

parameter_declaration : type_specifier declarator
                          | type_specifier

declaration :  type_specifier {init_declarator}* SEMICOLON 

init_declarator : declarator
                    | declarator EQUALS initializer

initializer : assignment_expression
                | { initializer_list }
                | { initializer_list , }

initializer_list : initializer
                     | initializer_list , initializer

compound_statement : LBRACE { declaration }* { statement }* RBRACE

statement : expression_statement
              | compound_statement
              | selection_statement
              | iteration_statement
              | jump_statement

expression_statement : {expression}? SEMICOLON

selection_statement : IF ( expression ) statement
                        | IF ( expression ) statement ELSE statement

iteration_statement : { WITH LPAREN expression RPAREN }? LOOP { UNTIL LPAREN expression RPAREN }? { UPDATE LPAREN expression RPAREN }? 
                            LBRACE { statement }? RBRACE

jump_statement : SKIP SEMICOLON
                   | EXIT SEMICOLON
                   | RETURN {expression}? SEMICOLON
